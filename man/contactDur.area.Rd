% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/contactDur.area.R
\name{contactDur.area}
\alias{contactDur.area}
\title{Identify Environmental Contacts}
\usage{
contactDur.area(x, dist.threshold = 1, sec.threshold = 10,
  blocking = TRUE, blockUnit = "mins", blockLength = 10,
  equidistant.time = FALSE, parallel = FALSE,
  nCores = parallel::detectCores(), reportParameters = TRUE)
}
\arguments{
\item{x}{Output from the distToArea function (either df or sf variant). Can 
be either a data frame or non-data-frame list.}

\item{dist.threshold}{Numeric. Radial distance (in meters) within which 
"contact" can be said to occur. Defaults to 1. Note: If you are defining 
conttacts as occurring when polygons intersect, set dist.threshold to 0.}

\item{sec.threshold}{Numeric. Dictates the maximum amount of time between 
concurrent observations during which potential "contact" events remain 
unbroken. Defaults to 10.}

\item{blocking}{Logical. If TRUE, contacts will be evaluated for temporal 
blocks spanning blockLength blockUnit (e.g., 6 hours) within the data 
set. Defaults to FALSE.}

\item{blockUnit}{Numerical. Describes the number blockUnits within each 
temporal block. Defaults to 1.}

\item{blockLength}{Character string taking the values, "secs," "mins," 
"hours," "days," or "weeks." Describes the temporal unit associated with 
each block. Defaults to "hours."}

\item{equidistant.time}{Logical. If TRUE, location fixes in individuals' 
movement paths are temporally equidistant (e.g., all fix intervals are 30
seconds). Defaults to FALSE. Note: This is a time-saving argument. A 
sub-function here calculates the time difference (dt) between each 
location fix. If all fix intervals are identical, it saves a lot of time.}

\item{parallel}{Logical. If TRUE, sub-functions within the contactDur.all 
wrapper will be parallelized. Note that this can significantly speed up 
processing of relatively small data sets, but may cause R to crash due to
lack of available memory when attempting to process large datasets. 
Defaults to FALSE.}

\item{nCores}{Integer. Describes the number of cores to be dedicated to 
parallel processes. Defaults to the maximum number of cores available
(i.e., parallel::detectCores()).}

\item{reportParameters}{Logical. If TRUE, function argument values will be 
appended to output data frame(s). Defaults to TRUE.}
}
\description{
This function uses the output from distToArea to determine when tracked 
   individuals are in "contact" with fixed locations. Individuals are said 
   to be in a "contact" event (h) if they are observed within a given 
   distance (<= dist.threshold) at a given timestep(i). Sec.threshold 
   dictates the maximum amount of time a single, potential "contact" event 
   should exist. For example, if sec.threshold=10, only "contacts" occurring
   within 10secs of one another will be regarded as a single "contact" event
   of duration sum(h). If in this case, a time difference between contacts 
   was 11 seconds, the function will report two separate contact events.
   
The output of this function is a data frame containing a time-ordered 
   contact edge set detailing animal-environment contacts.
}
\examples{
#load the calves data set
data(calves)

#pre-process the data
calves.dateTime<-datetime.append(calves, date = calves$date, 
  time = calves$time) #create a dataframe with dateTime identifiers for location fixes.

#delineate the water trough polygon (showing where the water trough in the calves' 
  #feedlot pen is)
water<- data.frame(x = c(61.43315, 61.89377, 62.37518, 61.82622),
                  y = c(62.44815, 62.73341, 61.93864, 61.67411)) 

#As noted in the dist2Area_df help documention, polygon-vertex coordinates 
  #must be arranged in a particular way. Here we arrange them accordingly.

water_poly<-data.frame(matrix(ncol = 8, nrow = 1)) #(ncol = number of vertices)*2
colnum = 0
for(h in 1:nrow(water)){
 water_poly[1,colnum + h] <- water$x[h] #pull the x location for each vertex
 water_poly[1, (colnum + 1 + h)] <- water$y[h] #pull the y location for each vertex
 colnum <- colnum + 1
}

#generate empirical time-ordered network edges.
water_dist<-contact::dist2Area_df(x = calves.dateTime, y = water_poly, 
  x.id = "calftag", y.id = "water", dateTime = "dateTime", point.x = calves.dateTime$x, 
  point.y = calves.dateTime$y, poly.xy = NULL, parallel = FALSE, dataType = "Point", 
  lonlat = FALSE, numVertices = NULL) #note that the poly.xy and numVertices arguments 
  
#refer to vertices of polygons in x, not y. Because dataType is "Point," not "Polygon," 
#these arguments are irrelevant here.

water_contacts <- contactDur.area(water_dist, dist.threshold=1,
  sec.threshold=10, blocking = FALSE, blockUnit = "mins", blockLength = 10,
  equidistant.time = FALSE, parallel = FALSE, reportParameters = TRUE)
  
#More examples coming later
}
\keyword{contact}
\keyword{data-processing}
